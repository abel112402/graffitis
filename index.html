<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="headerStyle.css">
<link rel="stylesheet" href="indexStyle.css">
<title>Kezdőlap</title>
<style>
  /* Apró kiegészítés, hogy a lista nézetben a sima elemek között legyen egy kis térköz */
  .simple-item {
    margin-bottom: 5px;
  }
</style>
</head>
<body>
<header></header>

<div id="main-container">
  <div id="main-container-left">
    
    <div id="year-list">
      <h3>Év</h3>
    </div>

    <div id="city-list">
      <h3>Város</h3>
    </div>
    
    <div id="category-list">
      <h3>Kategória</h3>
    </div>

    <button class="clear-filters" id="clear-filters">Szűrés törlése</button>
  </div>

  <div id="main-container-right">
    </div>
</div>

<script type="module">
import { supabase } from './supabaseClient.js';
import isAdmin from './isAdmin.js';

window.logout = async function logout() {
  await supabase.auth.signOut();
  alert('Kijelentkeztél.');
  location.href = '/';
}

let graffitiData = [];
let categoryMap = {};
let activeFilters = { year: null, city: null, category: [] };
// Új változó a nézet módjának tárolására: 'alphabetical' | 'random' | 'latest'
let currentMode = 'alphabetical';

async function loadIndex() {
  // Graffiti adatok lekérése - HOZZÁADVA: created_at
  const { data, error } = await supabase
    .from('graffiti')
    .select('id,name,slug,year,city,category_id,created_at')
    .eq('accepted', true)
    .order('name', { ascending: true });

  if (error) return console.error(error);
  graffitiData = data;

  // Kategória tábla lekérése
  const { data: catData, error: catError } = await supabase
    .from('category')
    .select('id, category_name');

  if (catError) return console.error(catError);
  catData.forEach(c => categoryMap[c.id] = c.category_name);

  // Year, city, category listák generálása
  const yearList = document.getElementById('year-list');
  const cityList = document.getElementById('city-list');
  const categoryList = document.getElementById('category-list');

  const years = [...new Set(data.map(g => g.year).filter(Boolean))].sort((a,b)=>a-b);
  const cities = [...new Set(data.map(g => g.city).filter(Boolean))]
    .sort((a, b) => a.localeCompare(b, 'hu', { sensitivity: 'base' }));
  const categories = [
    ...new Set(
      data
        .flatMap(g => g.category_id || [])
        .map(id => categoryMap[id])
        .filter(Boolean)
    )
  ].sort((a, b) => a.localeCompare(b, 'hu', { sensitivity: 'base' }));


  years.forEach(y => {
    const btn = document.createElement('span');
    btn.classList.add('filter-btn');
    btn.dataset.filter = 'year';
    btn.dataset.value = y;
    btn.innerText = y;
    btn.addEventListener('click', handleFilterClick);
    yearList.appendChild(btn);
  });

  cities.forEach(c => {
    const btn = document.createElement('span');
    btn.classList.add('filter-btn');
    btn.dataset.filter = 'city';
    btn.dataset.value = c;
    btn.innerText = c;
    btn.addEventListener('click', handleFilterClick);
    cityList.appendChild(btn);
  });

  categories.forEach(c => {
    const btn = document.createElement('span');
    btn.classList.add('filter-btn');
    btn.dataset.filter = 'category';
    btn.dataset.value = c;
    btn.innerText = c.toUpperCase();
    btn.addEventListener('click', handleFilterClick);
    categoryList.appendChild(btn);
  });

  document.getElementById('clear-filters').addEventListener('click', () => {
    activeFilters = { year:null, city:null, category:[] };
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active-filter'));
    // Visszaállunk ABC sorrendre is alaphelyzetben? 
    // Ha nem, akkor csak az applyFilters()-t hívjuk. 
    // Itt most a filter törlés visszaállítja a módot.
    currentMode = 'alphabetical';
    applyFilters();
  });

  // Kezdő renderelés
  applyFilters();

  // Header nav gombok
  const navUpper = document.createElement('div');
  navUpper.id = 'nav-upper';
  const navUpperLeft = document.createElement('div');
  navUpperLeft.id = 'nav-upper-left';
  const navUpperRight = document.createElement('div');
  navUpperRight.id = 'nav-upper-right';
  navUpper.appendChild(navUpperLeft);
  navUpper.appendChild(navUpperRight);
  const navLower = document.createElement('div');
  navLower.id = 'nav-lower';

  const adminLoggedIn = await isAdmin();

  const randomButton = document.createElement('div');
  randomButton.classList.add('nav-button');
  // Bekötjük az új függvényt
  randomButton.innerHTML = '<nav><a onclick="setRandomMode()">véletlenszerű</a></nav>';
  navUpperLeft.appendChild(randomButton);

  const lastButton = document.createElement('div');
  // Bekötjük az új függvényt
  lastButton.classList.add('nav-button');
  lastButton.innerHTML = '<nav><a onclick="setLastMode()">legutóbbi</a></nav>';
  navUpperLeft.appendChild(lastButton);

  const whatButton = document.createElement('div');
  whatButton.classList.add('nav-button');
  whatButton.innerHTML = '<nav><a onclick="">mi ez</a></nav>';
  navUpperRight.appendChild(whatButton);

  const whoButton = document.createElement('div');
  whoButton.classList.add('nav-button');
  whoButton.innerHTML = '<nav><a onclick="">ki ez</a></nav>';
  navUpperRight.appendChild(whoButton);

  if (!adminLoggedIn) {
    const loginButton = document.createElement('div');
    loginButton.innerHTML = '<nav><a href="./login.html">Admin Bejelentkezés</a></nav>';
    navUpper.appendChild(loginButton);
  } else {
    const adminProfile = document.createElement('div');
    adminProfile.innerHTML = '<nav><a href="./admin.html">Admin Oldal</a></nav>';
    navUpper.appendChild(adminProfile);

    const logoutButton = document.createElement('div');
    logoutButton.innerHTML = '<nav><a onclick="logout()">Kijelentkezés</a></nav>';
    navUpper.appendChild(logoutButton);
  }

  const uploadButton = document.createElement('div');
  uploadButton.id = 'upload-button';
  uploadButton.innerHTML = '<nav><a href="./upload.html">feltöltés</a></nav>';
  navLower.appendChild(uploadButton);

  document.querySelector('header').appendChild(navUpper);
  document.querySelector('header').appendChild(navLower);
}

// Globális függvények a gombokhoz
window.setRandomMode = function() {
  currentMode = 'random';
  applyFilters(); // Újra renderel a jelenlegi szűrőkkel, de random sorrendben
}

window.setLastMode = function() {
  currentMode = 'latest';
  applyFilters(); // Újra renderel a jelenlegi szűrőkkel, de időrendben
}

function handleFilterClick(e) {
  const btn = e.currentTarget;
  const type = btn.dataset.filter;
  const value = btn.dataset.value;

  if (type === 'category') {
    if (activeFilters.category.includes(value)) {
      activeFilters.category = activeFilters.category.filter(v => v !== value);
      btn.classList.remove('active-filter');
    } else {
      activeFilters.category.push(value);
      btn.classList.add('active-filter');
    }
  } else {
    if (activeFilters[type] === value) {
      activeFilters[type] = null;
      btn.classList.remove('active-filter');
    } else {
      activeFilters[type] = value;
      document.querySelectorAll(`.filter-btn[data-filter="${type}"]`).forEach(b => b.classList.remove('active-filter'));
      btn.classList.add('active-filter');
    }
  }

  applyFilters();
}

// Új segédfüggvény a szűrés és renderelés összekötésére
function applyFilters() {
  const filtered = graffitiData.filter(g => {
    const matchesYear = !activeFilters.year || g.year == activeFilters.year;
    const matchesCity = !activeFilters.city || g.city == activeFilters.city;

    const selectedCats = activeFilters.category;
    const gCats = (g.category_id || []).map(id => categoryMap[id]).filter(Boolean);

    const matchesCat = !selectedCats.length || 
                      selectedCats.every(cat => gCats.includes(cat));

    return matchesYear && matchesCity && matchesCat;
  });

  renderList(filtered);
}

function renderList(list) {
    const container = document.getElementById('main-container-right');
    container.innerHTML = '';
    
    // Elemek, amiket majd az oszlopelosztónak adunk át (lehet letter-group vagy sima div)
    let itemsToDistribute = [];

    // 1. ESET: ABC sorrend (Letter Groupokkal)
    if (currentMode === 'alphabetical') {
        // Alapból név szerint rendezzük (bár az SQL is így adja, de a szűrés miatt biztosra megyünk)
        list.sort((a, b) => a.name.localeCompare(b.name, 'hu', { sensitivity: 'base' }));

        const groups = {};
        list.forEach(g => {
            const letter = (g.name || '?').trim().charAt(0).toLowerCase();
            (groups[letter] ||= []).push(g);
        });

        const sortedLetters = Object.keys(groups)
            .sort((a, b) => a.localeCompare(b, 'hu', { sensitivity: 'base' }));

        itemsToDistribute = sortedLetters.map(letter => {
            const groupDiv = document.createElement('div');
            groupDiv.classList.add('letter-group');

            const h3 = document.createElement('h3');
            h3.innerText = letter;
            groupDiv.appendChild(h3);

            const ul = document.createElement('ul');
            groups[letter].forEach(item => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `graffiti.html?slug=${encodeURIComponent(item.slug)}`;
                a.innerText = item.name;
                li.appendChild(a);
                ul.appendChild(li);
            });

            groupDiv.appendChild(ul);
            return groupDiv;
        });

    } 
    // 2. ESET: Véletlenszerű vagy Legutóbbi (Nincs Letter Group)
    else {
        // Másolat készítése, hogy ne az eredeti tömböt rendezzük át
        let displayList = [...list];

        if (currentMode === 'random') {
            // Fisher-Yates shuffle vagy egyszerű random sort
            displayList.sort(() => Math.random() - 0.5);
        } else if (currentMode === 'latest') {
            // Dátum szerinti csökkenő sorrend
            displayList.sort((a, b) => {
                const dateA = new Date(a.created_at);
                const dateB = new Date(b.created_at);
                return dateB - dateA; // Legújabb elől
            });
        }

        // Sima DIV-ek gyártása az oszlopelosztónak
        itemsToDistribute = displayList.map(item => {
            const div = document.createElement('div');
            div.classList.add('simple-item'); // CSS-ben formázható ha kell
            
            const a = document.createElement('a');
            a.href = `graffiti.html?slug=${encodeURIComponent(item.slug)}`;
            a.innerText = item.name;
            a.style.display = 'block'; // Hogy új sorba kerüljön
            
            div.appendChild(a);
            return div;
        });
    }

    // Szétosztjuk oszlopokba a generált elemeket
    distributeColumns(itemsToDistribute, container);
}

function distributeColumns(divs, container) {
  container.innerHTML = '';
  if (!divs.length) return;

  const containerWidth = container.clientWidth;
  if (containerWidth === 0) return;

  const tempWrapper = document.createElement('div');
  tempWrapper.style.visibility = 'hidden';
  tempWrapper.style.position = 'absolute';
  document.body.appendChild(tempWrapper);

  const widths = divs.map(div => {
    tempWrapper.appendChild(div);
    const w = div.getBoundingClientRect().width;
    tempWrapper.removeChild(div);
    return Math.ceil(w);
  });

  document.body.removeChild(tempWrapper);

  const COL_GAP = 6; 
  const EXTRA = 20; 

  const minWidths = widths.map(w => w + EXTRA);

  let bestColCount = 1;
  // Kicsit növeljük a max oszlophatárt, ha sok kicsi elem van (pl. random nézetben)
  const maxCalcCols = currentMode === 'alphabetical' ? 7 : 20;

  for (let c = Math.min(divs.length, maxCalcCols); c >= 1; c--) { 
    const rows = Math.ceil(divs.length / c);
    const colMinWidths = new Array(c).fill(0);
    for (let i = 0; i < divs.length; i++) {
      const colIndex = Math.floor(i / rows); 
      if (colIndex < c) {
        colMinWidths[colIndex] = Math.max(colMinWidths[colIndex] || 0, minWidths[i]);
      }
    }
    const totalMinWidth = colMinWidths.reduce((s, v) => s + v, 0) + (c - 1) * COL_GAP;
    if (totalMinWidth <= containerWidth) {
      bestColCount = c;
      break;
    }
  }

  const colCount = bestColCount;
  const rows = Math.ceil(divs.length / colCount);

  const columns = Array.from({ length: colCount }, () => {
    const col = document.createElement('div');
    col.className = 'generated-column';
    col.style.display = 'flex';
    col.style.flexDirection = 'column';
    // Ha nem letter group, hanem sima lista, kisebb gap is elég
    col.style.gap = currentMode === 'alphabetical' ? '16px' : '5px';
    col.style.flex = '1 1 auto';
    col.style.alignItems = 'flex-start';
    container.appendChild(col);
    return col;
  });

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < colCount; col++) {
      const index = row + col * rows;
      if (index < divs.length) {
        columns[col].appendChild(divs[index]);
      }
    }
  }

  const colMinWidths = columns.map(col => {
    if (col.children.length === 0) return 0;
    let maxItem = 0;
    col.querySelectorAll('a').forEach(a => {
      const w = a.getBoundingClientRect().width;
      if (w > maxItem) maxItem = w;
    });
    for (let letterSep of col.querySelectorAll('.letter-group .letter-separator')) {
       letterSep.style.width = `${col.getBoundingClientRect().width}px`;
    }
    return Math.ceil(maxItem + EXTRA);
  });

  columns.forEach((col, i) => {
    if (colMinWidths[i] === 0) {
      col.style.display = 'none';
      return;
    }
    col.style.minWidth = `${colMinWidths[i]}px`;
    col.style.flex = '1 1 auto'; 
  });

  container.style.display = 'flex';
  container.style.gap = `${COL_GAP}px`;
  container.style.flexWrap = 'wrap';
  container.style.alignItems = 'flex-start';
  container.style.justifyContent = 'flex-start';
}

  window.addEventListener('DOMContentLoaded', loadIndex);
  window.addEventListener('resize', () => {
    if (graffitiData.length) applyFilters(); // Itt is applyFilters-t hívunk renderList helyett
  });
</script>
</body>
</html>