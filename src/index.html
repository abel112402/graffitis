<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="headerStyle.css">
<link rel="stylesheet" href="indexStyle.css">
<title>Kezdőlap</title>

</head>
<body>
<header></header>

<div id="main-container">
  <div id="main-container-left">
    
    <div id="year-list">
      <h3>Év</h3>
    </div>

    <div id="city-list">
      <h3>Város</h3>
    </div>
    
    <div id="category-list">
      <h3>Kategória</h3>
    </div>

    <button class="clear-filters" id="clear-filters">Szűrés törlése</button>
  </div>

  <div id="main-container-right">
    <!-- Itt jelennek meg a grafittik letter-group blokkokban -->
  </div>
</div>

<script type="module">
import { supabase } from './supabaseClient.js';
import isAdmin from './isAdmin.js';

window.logout = async function logout() {
  await supabase.auth.signOut();
  alert('Kijelentkeztél.');
  location.href = '/';
}

let graffitiData = [];
let categoryMap = {};
let activeFilters = { year: null, city: null, category: [] };

async function loadIndex() {
  // Graffiti adatok lekérése
  const { data, error } = await supabase
    .from('graffiti')
    .select('id,name,slug,year,city,category_id')
    .eq('accepted', true)
    .order('name', { ascending: true });

  if (error) return console.error(error);
  graffitiData = data;

  // Kategória tábla lekérése
  const { data: catData, error: catError } = await supabase
    .from('category')
    .select('id, category_name');

  if (catError) return console.error(catError);
  catData.forEach(c => categoryMap[c.id] = c.category_name);

  // Year, city, category listák generálása
  const yearList = document.getElementById('year-list');
  const cityList = document.getElementById('city-list');
  const categoryList = document.getElementById('category-list');

  const years = [...new Set(data.map(g => g.year).filter(Boolean))].sort((a,b)=>a-b);
  const cities = [...new Set(data.map(g => g.city).filter(Boolean))]
    .sort((a, b) => a.localeCompare(b, 'hu', { sensitivity: 'base' }));
  const categories = [
    ...new Set(
      data
        .flatMap(g => g.category_id || [])
        .map(id => categoryMap[id])
        .filter(Boolean)
    )
  ].sort((a, b) => a.localeCompare(b, 'hu', { sensitivity: 'base' }));


  years.forEach(y => {
    const btn = document.createElement('span');
    btn.classList.add('filter-btn');
    btn.dataset.filter = 'year';
    btn.dataset.value = y;
    btn.innerText = y;
    btn.addEventListener('click', handleFilterClick);
    yearList.appendChild(btn);
  });

  cities.forEach(c => {
    const btn = document.createElement('span');
    btn.classList.add('filter-btn');
    btn.dataset.filter = 'city';
    btn.dataset.value = c;
    btn.innerText = c;
    btn.addEventListener('click', handleFilterClick);
    cityList.appendChild(btn);
  });

  categories.forEach(c => {
    const btn = document.createElement('span');
    btn.classList.add('filter-btn');
    btn.dataset.filter = 'category';
    btn.dataset.value = c;
    btn.innerText = c.toUpperCase();
    btn.addEventListener('click', handleFilterClick);
    categoryList.appendChild(btn);
  });

  document.getElementById('clear-filters').addEventListener('click', () => {
    activeFilters = { year:null, city:null, category:[] };
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active-filter'));
    renderList(graffitiData);
  });

  renderList(graffitiData);

  // Header nav gombok
  const adminLoggedIn = await isAdmin();
  if (!adminLoggedIn) {
    const loginButton = document.createElement('div');
    loginButton.innerHTML = '<nav><a href="./login.html">Admin Bejelentkezés</a></nav>';
    document.querySelector('header').appendChild(loginButton);
  } else {
    const adminProfile = document.createElement('div');
    adminProfile.innerHTML = '<nav><a href="./admin.html">Admin Oldal</a></nav>';
    document.querySelector('header').appendChild(adminProfile);

    const logoutButton = document.createElement('div');
    logoutButton.innerHTML = '<nav><a onclick="logout()">Kijelentkezés</a></nav>';
    document.querySelector('header').appendChild(logoutButton);
  }

  const uploadButton = document.createElement('div');
  uploadButton.id = 'upload-button';
  uploadButton.innerHTML = '<nav><a href="./upload.html">Graffiti Feltöltés</a></nav>';
  document.querySelector('header').appendChild(uploadButton);
}

function handleFilterClick(e) {
  const btn = e.currentTarget;
  const type = btn.dataset.filter;
  const value = btn.dataset.value;

  if (type === 'category') {
    if (activeFilters.category.includes(value)) {
      activeFilters.category = activeFilters.category.filter(v => v !== value);
      btn.classList.remove('active-filter');
    } else {
      activeFilters.category.push(value);
      btn.classList.add('active-filter');
    }
  } else {
    if (activeFilters[type] === value) {
      activeFilters[type] = null;
      btn.classList.remove('active-filter');
    } else {
      activeFilters[type] = value;
      document.querySelectorAll(`.filter-btn[data-filter="${type}"]`).forEach(b => b.classList.remove('active-filter'));
      btn.classList.add('active-filter');
    }
  }

  const filtered = graffitiData.filter(g => {
    const matchesYear = !activeFilters.year || g.year == activeFilters.year;
    const matchesCity = !activeFilters.city || g.city == activeFilters.city;

    const selectedCats = activeFilters.category;
    const gCats = (g.category_id || []).map(id => categoryMap[id]).filter(Boolean);

    const matchesCat = !selectedCats.length || 
                      selectedCats.every(cat => gCats.includes(cat));

    return matchesYear && matchesCity && matchesCat;
  });

  renderList(filtered);
}

function adjustGridColumns() {
  const container = document.getElementById('main-container-right');
  const groups = Array.from(container.querySelectorAll('.letter-group'));
  if (!groups.length) return;

  const containerWidth = container.clientWidth;
  const maxGroupWidth = Math.max(...groups.map(g => g.getBoundingClientRect().width));

  // hány oszlop fér el ténylegesen
  const maxPossibleCols = Math.min(groups.length, Math.floor(containerWidth / maxGroupWidth) || 1);

  const rows = Math.ceil(groups.length / maxPossibleCols);

  // remove everything
  container.innerHTML = '';

  // create columns dynamically (csak amennyi kell)
  const columns = Array.from({ length: maxPossibleCols }, () => {
    const col = document.createElement('div');
    col.style.display = 'flex';
    col.style.flexDirection = 'column';
    col.style.gap = '20px';
    col.style.flex = '1'; // kitölti a szélességet
    container.appendChild(col);
    return col;
  });

  // column-first elrendezés
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < maxPossibleCols; col++) {
      const index = row + col * rows;
      if (index < groups.length) {
        columns[col].appendChild(groups[index]);
      }
    }
  }
}

function renderList(list) {
    const container = document.getElementById('main-container-right');
    container.innerHTML = '';

    // Csoportosítás kezdőbetű szerint
    const groups = {};
    list.forEach(g => {
      const letter = (g.name || '?').trim().charAt(0).toUpperCase();
      (groups[letter] ||= []).push(g);
    });

    const sortedLetters = Object.keys(groups)
      .sort((a, b) => a.localeCompare(b, 'hu', { sensitivity: 'base' }));

    // Készítsünk letter-group div-eket
    const letterDivs = sortedLetters.map(letter => {
      const groupDiv = document.createElement('div');
      groupDiv.classList.add('letter-group');

      const h3 = document.createElement('h3');
      h3.innerText = letter;
      groupDiv.appendChild(h3);
      const hr = document.createElement('hr');
      hr.classList.add('letter-separator');
      groupDiv.appendChild(hr);

      const ul = document.createElement('ul');
      groups[letter].forEach(item => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = `graffiti.html?slug=${encodeURIComponent(item.slug)}`;
        a.innerText = item.name;
        li.appendChild(a);
        ul.appendChild(li);
      });

      groupDiv.appendChild(ul);
      return groupDiv;
    });

    // Szétosztjuk oszlopokba
    distributeColumns(letterDivs, container);
  }

function distributeColumns(divs, container) {
  container.innerHTML = '';
  if (!divs.length) return;

  const containerWidth = container.clientWidth;
  if (containerWidth === 0) return;

  // ideiglenes mérés: appendoljuk, hogy megkapjuk a pontos szélességeket
  const tempWrapper = document.createElement('div');
  tempWrapper.style.visibility = 'hidden';
  tempWrapper.style.position = 'absolute';
  document.body.appendChild(tempWrapper);

  const widths = divs.map(div => {
    tempWrapper.appendChild(div);
    const w = div.getBoundingClientRect().width;
    tempWrapper.removeChild(div);
    return Math.ceil(w);
  });

  document.body.removeChild(tempWrapper);

  // padding/puffer minden oszlophoz (pl. padding + belső space)
  const COL_GAP = 6; // px, oszlopok közötti távolság
  const EXTRA = 20;   // px puffer minden oszlophoz (paddingok miatt)

  // Minden divhez a szükséges min-width (linkek szélessége + EXTRA)
  const minWidths = widths.map(w => w + EXTRA);

  // Próbáljuk meg a legnagyobb colCount-ot, amivel elférnek a min-width-ek
  // legfeljebb divs.length oszlop lehet
  let bestColCount = 1;
  for (let c = Math.min(divs.length, 12); c >= 1; c--) { // 12 korlát pl. ne legyen nagyon nagy
    // oszloponként hogyan osztanánk? column-first, rows = ceil(n / c)
    const rows = Math.ceil(divs.length / c);
    // kiszámoljuk minden oszlop min szélességét (max az adott oszlop elemei között)
    const colMinWidths = new Array(c).fill(0);
    for (let i = 0; i < divs.length; i++) {
      const colIndex = Math.floor(i / rows); // column-first index map
      if (colIndex < c) {
        colMinWidths[colIndex] = Math.max(colMinWidths[colIndex] || 0, minWidths[i]);
      }
    }
    const totalMinWidth = colMinWidths.reduce((s, v) => s + v, 0) + (c - 1) * COL_GAP;
    if (totalMinWidth <= containerWidth) {
      bestColCount = c;
      break;
    }
  }

  const colCount = bestColCount;
  const rows = Math.ceil(divs.length / colCount);

  // készítsük el az oszlopokat
  const columns = Array.from({ length: colCount }, () => {
    const col = document.createElement('div');
    col.className = 'generated-column';
    // flex beállítás: engedjük növekedni, de ne zsugorodjon a min-width alá
    col.style.display = 'flex';
    col.style.flexDirection = 'column';
    col.style.gap = '16px';
    col.style.flex = '1 1 auto';
    col.style.alignItems = 'flex-start';
    container.appendChild(col);
    return col;
  });

  // column-first feltöltés (ABC oszloponként)
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < colCount; col++) {
      const index = row + col * rows;
      if (index < divs.length) {
        columns[col].appendChild(divs[index]);
      }
    }
  }

  // minden oszlophoz állapítsuk meg a min-width-et (benne a leghosszabb elem alapján)
  const colMinWidths = columns.map(col => {
    if (col.children.length === 0) return 0;
    let maxItem = 0;
    col.querySelectorAll('a').forEach(a => {
      const w = a.getBoundingClientRect().width;
      if (w > maxItem) maxItem = w;
    });
    for (let letterSep of col.querySelectorAll('.letter-group .letter-separator')) {
      letterSep.style.width = `${col.getBoundingClientRect().width}px`;
   }
    return Math.ceil(maxItem + EXTRA);
  });

  // állítsuk be a min-width-et minden oszlopra, és flex-grow megtartása
  columns.forEach((col, i) => {
    if (colMinWidths[i] === 0) {
      col.style.display = 'none';
      return;
    }
    col.style.minWidth = `${colMinWidths[i]}px`;
    col.style.flex = '1 1 auto'; // kitölti a maradékot, de nem lesz kisebb mint minWidth
  });

  // konténer stílus
  container.style.display = 'flex';
  container.style.gap = `${COL_GAP}px`;
  container.style.flexWrap = 'wrap';
  container.style.alignItems = 'flex-start';
  container.style.justifyContent = 'flex-start';
}





  window.addEventListener('DOMContentLoaded', loadIndex);
  window.addEventListener('resize', () => {
    if (graffitiData.length) renderList(graffitiData);
  });
</script>
</body>
</html>
